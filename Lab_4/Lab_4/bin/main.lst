
Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
    1    1                      ;**************************************************************************************
    2    2                      ;* Lab 4 [includes LibV2.2]                                                           *
    3    3                      ;**************************************************************************************
    4    4                      ;* Summary: Function Generator                                                        *
    5    5                      ;*   -                                                                                *
    6    6                      ;*                                                                                    *
    7    7                      ;* Author: Benjamin Fields, Miles Alderman                                            *
    8    8                      ;*   Cal Poly University                                                              *
    9    9                      ;*   Spring 2022                                                                      *
   10   10                      ;*                                                                                    *
   11   11                      ;* Revision History:                                                                  *
   12   12                      ;*   -                                                                                *
   13   13                      ;*                                                                                    *
   14   14                      ;* ToDo:                                                                              *
   15   15                      ;*   -                                                                                *
   16   16                      ;**************************************************************************************
   17   17                      
   18   18                      ;/------------------------------------------------------------------------------------\
   19   19                      ;| Include all associated files                                                       |
   20   20                      ;\------------------------------------------------------------------------------------/
   21   21                      ; The following are external files to be included during assembly
   22   22                      
   23   23                      
   24   24                      ;/------------------------------------------------------------------------------------\
   25   25                      ;| External Definitions                                                               |
   26   26                      ;\------------------------------------------------------------------------------------/
   27   27                      ; All labels that are referenced by the linker need an external definition
   28   28                      
   29   29                                    XDEF  main
   30   30                      
   31   31                      ;/------------------------------------------------------------------------------------\
   32   32                      ;| External References                                                                |
   33   33                      ;\------------------------------------------------------------------------------------/
   34   34                      ; All labels from other files must have an external reference
   35   35                      
   36   36                                    XREF  ENABLE_MOTOR, DISABLE_MOTOR
   37   37                                    XREF  STARTUP_MOTOR, UPDATE_MOTOR, CURRENT_MOTOR
   38   38                                    XREF  STARTUP_PWM, STARTUP_ATD0, STARTUP_ATD1
   39   39                                    XREF  OUTDACA, OUTDACB
   40   40                                    XREF  STARTUP_ENCODER, READ_ENCODER
   41   41                                    XREF  INITLCD, SETADDR, GETADDR, CURSOR_ON, CURSOR_OFF, DISP_OFF
   42   42                                    XREF  OUTCHAR, OUTCHAR_AT, OUTSTRING, OUTSTRING_AT
   43   43                                    XREF  INITKEY, LKEY_FLG, GETCHAR
   44   44                                    XREF  LCDTEMPLATE, UPDATELCD_L1, UPDATELCD_L2
   45   45                                    XREF  LVREF_BUF, LVACT_BUF, LERR_BUF,LEFF_BUF, LKP_BUF, LKI_BUF
   46   46                                    XREF  Entry, ISR_KEYPAD
   47   47                                  
   48   48                      ;/------------------------------------------------------------------------------------\
   49   49                      ;| Assembler Equates                                                                  |
   50   50                      ;\------------------------------------------------------------------------------------/
   51   51                      ; Constant values can be equated here
   52   52                      
   53   53          0000 03E0   INTERVAL      EQU   $03E0        ;number of clock pulses that equal 0.1ms from 10.2MHz clock
   54   54                      
   55   55          0000 0040   TIOS          EQU   $0040        ; addr of tios register
   56   56          0000 0001   Chan0         EQU   %00000001    ;offset for channel 0
   57   57                      
   58   58          0000 0049   TCTL2         EQU   $0049        ; TCTL2 register that contains OL0 and OM0
   59   59          0000 0001   OL0           EQU   %00000001    ; mask for 0L0 in TCTL2
   60   60                      
   61   61          0000 004E   TFLG1         EQU   $004E        ; Main timer interupt flag 1
   62   62          0000 0001   C0F           EQU   %00000001    ; mask for C0F in TFLG1
   63   63                      
   64   64          0000 004C   TMSK1         EQU   $004C        ; Timer interupt mask

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
   65   65          0000 0001   C0I           EQU   %00000001    ; mask for C0I
   66   66                      
   67   67          0000 0046   TSCR          EQU   $0046        ; Timer system control
   68   68          0000 00A0   TSCR_msk      EQU   %10100000    ; mask for timer system control
   69   69                      
   70   70          0000 0044   TCNT          EQU   $0044        ; first byte of timer count register
   71   71                      
   72   72          0000 0050   TC0           EQU   $0050        ; Timer channel 0 first (high) byte
   73   73                      ;/------------------------------------------------------------------------------------\
   74   74                      ;| Variables in RAM                                                                   |
   75   75                      ;\------------------------------------------------------------------------------------/
   76   76                      ; The following variables are located in unpaged ram
   77   77                      
   78   78                      DEFAULT_RAM:  SECTION
   79   79                      
   80   80   000000             NINT:               DS.B     1 
   81   81   000001             timerstate:         DS.B     1
   82   82   000002             masterstate:        DS.B     1
   83   83   000003             displaystate:       DS.B     1
   84   84   000004             keystate:           DS.B     1
   85   85   000005             fxngenstate:        DS.B     1
   86   86   000006             RUN_FLG:            DS.B     1
   87   87   000007             FIRSTCH:            DS.B     1
   88   88   000008             DPTR:               DS.W     1
   89   89   00000A             LASTCH:             DS.B     1
   90   90   00000B             ERRORCOUNT:         DS.W     1
   91   91   00000D             KEY_COUNT:          DS.B     1        ; Number of digits in buffer
   92   92   00000E             KEY_BUFFER:         DS.B     1        ; Intermediate ascii key holder 
   93   93   00000F             BUFFER:             DS.B     3        ; Storage for pressed keys pre-translation
   94   94   000012             ERR_FLG             DS.B     1        ; Flag for there was an error, go into error state
   95   95   000013             TEMP:               DS.B     1        ; temporary used in ascii->bcd
   96   96   000014             RESULT:             DS.W     1        ; used for result storage of ascii -> bcd conversion
   97   97   000016             COUNT:              DS.B     1        ; used for counting in ascii -> bcd
   98   98   000017             ECHO:               DS.B     1        ; echo character for indexed addressing storage
   99   99   000018             DMESS_EB:           DS.B     1
  100  100   000019             DMESS_EZ:           DS.B     1
  101  101   00001A             DMESS_EN:           DS.B     1
  102  102   00001B             DMESS_ENT:          DS.B     1
  103  103   00001C             DMESS_BS:           DS.B     1
  104  104   00001D             DMESS_NINT:         DS.B     1
  105  105   00001E             DMESS_RESET:        DS.B     1
  106  106   00001F             KEY_FLG:            DS.B     1
  107  107                      
  108  108   000020             DMESS_tmp_err:      DS.B     1        ; for testing delete later TODO
  109  109                      
  110  110   000021             NEW_BTI:            DS.B     1        ; from Murray: flag that ready for new BTI
  111  111   000022             CSEG:               DS.B     1
  112  112   000023             CINT:               DS.B     1
  113  113   000024             LSEG:               DS.B     1
  114  114   000025             VALUE:              DS.W     1
  115  115   000027             SEGINC:             DS.W     1    
  116  116   000029             SEGPTR:             DS.W     1        
  117  117   00002B             WAVE:               DS.B     1 
  118  118                      
  119  119   00002C             DWAVE:              DS.B     1    
  120  120   00002D             DPROMPT:            DS.B     1
  121  121   00002E             CURSOR_ADD:         DS.B     1
  122  122   00002F             WAVEPTR:            DS.W     1
  123  123   000031             NINT_OK:            DS.B     1
  124  124   000032             MS_WAVE_FLG:        DS.B     1    
  125  125                      
  126  126                      
  127  127                      ;/------------------------------------------------------------------------------------\
  128  128                      ;|  Main Program Code                                                                 |

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  129  129                      ;\------------------------------------------------------------------------------------/
  130  130                      ; Your code goes here
  131  131                      
  132  132                      MyCode:       SECTION
  133  133                      
  134  134                      main:   
  135  135   000000 79xx xx             clr   NINT
  136  136   000003 79xx xx             clr   masterstate
  137  137   000006 79xx xx             clr   timerstate
  138  138   000009 79xx xx             clr   displaystate
  139  139   00000C 79xx xx             clr   keystate
  140  140   00000F 79xx xx             clr   fxngenstate
  141  141   000012 79xx xx             clr   RUN_FLG
  142  142   000015 79xx xx             clr   KEY_COUNT
  143  143   000018 79xx xx             clr   KEY_BUFFER
  144  144   00001B 79xx xx             clr   ERR_FLG
  145  145   00001E 79xx xx             clr   TEMP
  146  146   000021 1879 xxxx           clrw  RESULT
  147  147   000025 79xx xx             clr   COUNT
  148  148   000028 79xx xx             clr   DMESS_EB
  149  149   00002B 79xx xx             clr   DMESS_EZ
  150  150   00002E 79xx xx             clr   DMESS_EN
  151  151   000031 79xx xx             clr   DMESS_ENT
  152  152   000034 79xx xx             clr   DMESS_BS
  153  153   000037 79xx xx             clr   DMESS_NINT
  154  154   00003A 79xx xx             clr   DMESS_RESET
  155  155   00003D 79xx xx             clr   KEY_FLG
  156  156   000040 79xx xx             clr   NEW_BTI
  157  157   000043 79xx xx             clr   DMESS_tmp_err
  158  158   000046 79xx xx             clr   WAVE
  159  159   000049 79xx xx             clr   DWAVE
  160  160   00004C 79xx xx             clr   DPROMPT
  161  161   00004F 79xx xx             clr   CURSOR_ADD
  162  162   000052 79xx xx             clr   WAVEPTR
  163  163   000055 79xx xx             clr   NINT_OK
  164  164   000058 79xx xx             clr   ECHO
  165  165   00005B 79xx xx             clr   MS_WAVE_FLG
  166  166   00005E 79xx xx             clr   CSEG
  167  167   000061 79xx xx             clr   LSEG
  168  168   000064 79xx xx             clr   VALUE
  169  169   000067 79xx xx             clr   SEGINC
  170  170   00006A 79xx xx             clr   SEGPTR
  171  171   00006D 79xx xx             clr   CINT
  172  172                      top:        
  173  173   000070 16xx xx             jsr   timer_channel_0
  174  174   000073 16xx xx             jsr   MASTERMIND
  175  175   000076 16xx xx             jsr   display
  176  176   000079 16xx xx             jsr   keypad
  177  177   00007C 16xx xx             jsr   function_generator
  178  178   00007F 20EF                bra   top
  179  179                              
  180  180   000081 20FE        spin:   bra  spin
  181  181                              
  182  182                      ;//////////////////////////TIMER CHANNEL 0/////////////////////////////////////        
  183  183                      timer_channel_0:
  184  184                              
  185  185   000083 B6xx xx             ldaa  timerstate
  186  186   000086 2707                beq   timerstate0
  187  187   000088 43                  deca
  188  188   000089 2728                beq   timerstate1
  189  189   00008B 43                  deca
  190  190   00008C 2736                beq   timerstate2
  191  191   00008E 3D                  rts
  192  192                              

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  193  193                      timerstate0:
  194  194   00008F 4C40 01             bset  TIOS, Chan0              ; set timer chan 0 for output compare
  195  195   000092 4C49 01             bset  TCTL2, OL0               ; toggle tc0 for successful compare, OM0:OL0 should be 01
  196  196   000095 4C4E 01             bset  TFLG1, C0F               ; clear timer output compare flag by writing a 1 to it
  197  197   000098 10EF                cli                            ; clear I bit to enable maskable interupts
  198  198   00009A 4C4C 01             bset  TMSK1, C0I               ; enable timer overflow flag to trigger input
  199  199   00009D 4C46 A0             bset  TSCR, TSCR_msk           ; freeze mode when debugger stops executing
  200  200   0000A0 DC44                ldd   TCNT                     ; load $0044:$0045 into d
  201  201   0000A2 C303 E0             addd  #INTERVAL                ; add interval to timer count
  202  202   0000A5 5C50                std   TC0                      ; store in timer channel 0
  203  203   0000A7 180B 01xx           movb  #$01, timerstate
             0000AB xx         
  204  204   0000AC 4D4C 01             bclr  TMSK1, C0I
  205  205   0000AF 4D49 01             bclr  TCTL2, OL0               ; initiate with interrupts off
  206  206   0000B2 3D                  rts
  207  207                      
  208  208                      timerstate1:                           ; waiting to turn on interrupts
  209  209   0000B3 F7xx xx             tst   RUN_FLG                  ; if RUN=1, enable interrupts
  210  210   0000B6 270B                beq   timerstate1exit
  211  211   0000B8 4C4C 01             bset  TMSK1, C0I               ; enable timer overflow flag to trigger input
  212  212   0000BB 4C49 01             bset  TCTL2, OL0               ; set output to toggle
  213  213   0000BE 180B 02xx           movb  #$02, timerstate         ; go to wait for interrupt disable
             0000C2 xx         
  214  214                              
  215  215                      timerstate1exit:
  216  216   0000C3 3D                  rts
  217  217                      
  218  218                      timerstate2:                           ; waiting to turn off interrupts
  219  219   0000C4 F7xx xx             tst   RUN_FLG                  
  220  220   0000C7 260B                bne   timerstate2exit          ; if RUN=0, fall through else exit
  221  221   0000C9 4D4C 01             bclr  TMSK1, C0I               ; disable timer overflow flag
  222  222   0000CC 4D49 01             bclr  TCTL2, OL0               ; clear toggle output
  223  223   0000CF 180B 01xx           movb  #$01, timerstate         ; go to wait for interrupt enable
             0000D3 xx         
  224  224                              
  225  225                      timerstate2exit:
  226  226   0000D4 3D                  rts
  227  227                              
  228  228                      ;//////////////////////////MASTERMIND/////////////////////////////////////////////////         
  229  229                      MASTERMIND:
  230  230                      
  231  231                      masterloop:        
  232  232   0000D5 B6xx xx             ldaa   masterstate
  233  233   0000D8 1827 0025           lbeq   masterstate0             ; init state
  234  234   0000DC 43                  deca
  235  235   0000DD 1827 002B           lbeq   masterstate1             ; waiting for key press state
  236  236   0000E1 43                  deca
  237  237   0000E2 1827 003E           lbeq   masterstate2             ; decode state
  238  238   0000E6 43                  deca
  239  239   0000E7 1827 006D           lbeq   masterstate3             ; wave key state
  240  240   0000EB 43                  deca
  241  241   0000EC 1827 009B           lbeq   masterstate4             ; nint key state
  242  242   0000F0 43                  deca
  243  243   0000F1 1827 00AB           lbeq   masterstate5             ; backspace key state
  244  244   0000F5 43                  deca
  245  245   0000F6 1827 00B9           lbeq   masterstate6             ; enter key state
  246  246   0000FA 43                  deca
  247  247   0000FB 1827 011E           lbeq   masterstate7             ; error state          
  248  248                              
  249  249                              
  250  250   0000FF 20D4                bra   masterloop       
  251  251                      
  252  252                      masterstate0: ; // INIT STATE  ///////////////////////////////////////////////////////////
  253  253   000101 180B 01xx           movb  #$01, masterstate

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
             000105 xx         
  254  254   000106 180B 01xx           movb  #$01, MS_WAVE_FLG         ;flag to set initial post decode waiting for wave
             00010A xx         
  255  255   00010B 3D                  rts
  256  256                              
  257  257                      masterstate1: ; // WAITING FOR KEY STATE //////////////////////////////////////////////////
  258  258   00010C F7xx xx             tst   ERR_FLG                    ; no error if flag is 0
  259  259   00010F 260C                bne   errorstateset              ; go to error routine if there is one
  260  260   000111 F7xx xx             tst   KEY_FLG                    ; test if key has been pressed
  261  261   000114 270D                beq   exitmasterstate1
  262  262   000116 180B 02xx           movb  #$02, masterstate          ; if so go to decode state
             00011A xx         
  263  263   00011B 2006                bra   exitmasterstate1
  264  264                      
  265  265                      errorstateset:                          ; TODO: will the specific error determination all be in error state? 
  266  266   00011D 180B 07xx           movb  #$07, masterstate
             000121 xx         
  267  267   000122 3D                  rts
  268  268                      
  269  269                      exitmasterstate1:        
  270  270   000123 3D                  rts
  271  271                              
  272  272                      masterstate2: ; // DECODE STATE   /////////////////////////////////////////////////////////
  273  273                              ; decode state will only figure out which key it is and then redirected to the appropriate state
  274  274                              ; error checking and more advanced case handling will be done in respective key states
  275  275                      
  276  276                              
  277  277   000124 B6xx xx             ldaa  KEY_BUFFER                ; load ascii code for pressed key
  278  278                             
  279  279   000127 8108                cmpa  #$08                      ; check if key is a backspace key
  280  280   000129 271D                beq   ms_goto_bs
  281  281                      
  282  282   00012B 810A                cmpa  #$0A                      ; check if key is an enter key
  283  283   00012D 271F                beq   ms_goto_ent
  284  284                      
  285  285   00012F 8130                cmpa  #$30                      ; check if key is less than ascii for 0
  286  286   000131 2D21                blt   ignore                 
  287  287                              
  288  288   000133 8139                cmpa  #$39                      ; check if key is more than ascii 9
  289  289   000135 221D                bhi   ignore                 
  290  290   000137 F7xx xx             tst   MS_WAVE_FLG               ; check if we are currently waiting for wave select
  291  291   00013A 2706                beq   ms_goto_nint              ; if not branch to nint designation
  292  292                              
  293  293                      ms_goto_wave:                                        ; if it didn't branch, we have a digit!
  294  294   00013C 180B 03xx           movb  #$03, masterstate         ; go into WAVE state next pass through MM                                 
             000140 xx         
  295  295   000141 3D                  rts
  296  296                              
  297  297                      ms_goto_nint:
  298  298   000142 180B 04xx           movb  #$04, masterstate         ; go into NINT state next pass through MM
             000146 xx         
  299  299   000147 3D                  rts
  300  300                      
  301  301                      ms_goto_bs:
  302  302   000148 180B 05xx           movb  #$05, masterstate         ; go into backspace state next pass through MM
             00014C xx         
  303  303   00014D 3D                  rts 
  304  304                      
  305  305                      ms_goto_ent:
  306  306   00014E 180B 06xx           movb  #$06, masterstate         ; go into enter state next pass through MM
             000152 xx         
  307  307   000153 3D                  rts 
  308  308                      
  309  309                      ignore:

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  310  310   000154 16xx xx             jsr   clear_key
  311  311   000157 3D                  rts
  312  312                      
  313  313                      
  314  314                      masterstate3: ;//  WAVE KEY STATE  ///////////////////////////////////////////////////////////
  315  315                      
  316  316                      
  317  317                      waveinteruption:
  318  318                              
  319  319   000158 180B 00xx           movb   #$00, RUN_FLG            ; turn off interrupt running
             00015C xx         
  320  320                      
  321  321   00015D B6xx xx             ldaa   KEY_BUFFER
  322  322   000160 8130                cmpa   #$30                     ; if digit is 0, send display reset message
  323  323   000162 271E                beq    wavereset                ; keep waiting for a wave
  324  324                              
  325  325   000164 8131                cmpa   #$31                     ; check if digit is less than 1
  326  326   000166 2D1F                blt    digexit                 
  327  327                              
  328  328   000168 8134                cmpa   #$34                     ; check if digit is more than 4
  329  329   00016A 221B                bhi    digexit                 
  330  330                              
  331  331   00016C 8030                suba   #$30                     ; made it through! convert from ascii to bcd
  332  332   00016E 7Axx xx             staa   WAVE                     ; digit has now selected wave
  333  333                              
  334  334   000171 180B 01xx           movb   #$01, DWAVE              ; set DWAVE flag - WHY?
             000175 xx         
  335  335   000176 180B 01xx           movb   #$01, NEW_BTI 
             00017A xx         
  336  336   00017B 180B 00xx           movb   #$00, MS_WAVE_FLG        ; on next pass through MM-digit assume for NINT
             00017F xx         
  337  337                              
  338  338   000180 2005                bra    digexit 
  339  339                              
  340  340                      wavereset:
  341  341   000182 180B 01xx           movb   #$01, DMESS_RESET        ;send display reset message
             000186 xx         
  342  342                              
  343  343                      digexit:
  344  344   000187 16xx xx             jsr    clear_key
  345  345   00018A 3D                  rts        
  346  346                                        
  347  347                      
  348  348                      masterstate4: ;// NINT KEY STATE  ///////////////////////////////////////////////////////////           
  349  349                      
  350  350                      nintput:
  351  351   00018B F6xx xx             ldab   KEY_COUNT
  352  352   00018E C102                cmpb   #$02                     ;test key count, if more than 2 in buffer already,
  353  353   000190 220A                bhi    dig_exit                 ;don't store
  354  354   000192 16xx xx             jsr    buffer_store             ;if ok store in buffer
  355  355   000195 180B 01xx           movb   #$01, DPROMPT            ;tell display to print the digit
             000199 xx         
  356  356   00019A 2000                bra    dig_exit
  357  357                                                                      
  358  358                      dig_exit:
  359  359   00019C 16xx xx             jsr    clear_key
  360  360   00019F 3D                  rts
  361  361                      
  362  362                      
  363  363                      masterstate5: ;//  BACKSPACE KEY STATE  ///////////////////////////////////////////////////////
  364  364   0001A0 F7xx xx             tst    KEY_COUNT                ; check that key count isn't at 0
  365  365   0001A3 270A                beq    bs_exit                  ; if there are no digits to backspace, ignore key press      
  366  366                                    ; if there's somethign to bs:
  367  367   0001A5 73xx xx             dec    KEY_COUNT                ; decrement key_count

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  368  368   0001A8 180B 01xx           movb   #$01, DMESS_BS           ; set the display backspace flag     
             0001AC xx         
  369  369                              
  370  370   0001AD 2000                bra    bs_exit
  371  371                      
  372  372                      bs_exit:
  373  373   0001AF 16xx xx             jsr    clear_key
  374  374   0001B2 3D                  rts
  375  375                              
  376  376                      masterstate6: ;//  ENTER KEY STATE  ///////////////////////////////////////////////////////////
  377  377                              
  378  378                              
  379  379   0001B3 F7xx xx             tst    MS_WAVE_FLG              ; test if currently accepting waves
  380  380   0001B6 2637                bne    ent_exit                 ; exit if not
  381  381                              
  382  382   0001B8 F7xx xx             tst    DPROMPT                  ; first test if it is an appropriate time to press enter
  383  383   0001BB 2632                bne    ent_exit                 ; exit if not
  384  384                              
  385  385   0001BD F7xx xx             tst    KEY_COUNT                ; check for zero key error
  386  386   0001C0 1827 004B           lbeq   null_error               
  387  387                              
  388  388   0001C4 16xx xx             jsr    asc_decode               ; translate ascii to BCD
  389  389   0001C7 7Axx xx             staa   ERR_FLG                  ; a is error code from ascii -> bcd, 0 if no error
  390  390                                 
  391  391   0001CA 8102                cmpa   #$02       
  392  392   0001CC 2733                beq    zero_error               ; test for zero result
  393  393                                                 
  394  394   0001CE 8101                cmpa   #$01                     ; check for magnitude thats too large for nint
  395  395   0001D0 2721                beq    magnitude_error
  396  396                             
  397  397                      enter:                                  ; only occurs if completely valid
  398  398   0001D2 180B 01xx           movb  #$01, DMESS_ENT           ; set the display enter flag
             0001D6 xx         
  399  399   0001D7 79xx xx             clr   KEY_COUNT                 ; reset key_count to 0
  400  400   0001DA 79xx xx             clr   DPROMPT                   ; clear prompt message
  401  401   0001DD 180B 01xx           movb  #$01, NINT_OK             ; signal OK to start generating
             0001E1 xx         
  402  402   0001E2 180B 01xx           movb  #$01, MS_WAVE_FLG         ; signal OK to accept new wave numbers
             0001E6 xx         
  403  403   0001E7 FCxx xx             ldd   RESULT
  404  404   0001EA 7Bxx xx             stab  NINT
  405  405   0001ED 2000                bra   ent_exit
  406  406                              
  407  407                      ent_exit:                               ; now that we are exiting...
  408  408   0001EF 16xx xx             jsr   clear_key                 ; we are done with key
  409  409   0001F2 3D                  rts
  410  410                      
  411  411                      magnitude_error:
  412  412   0001F3 180B 01xx           movb  #$01, DMESS_EB            ; set magnitude error flag    
             0001F7 xx         
  413  413   0001F8 16xx xx             jsr   clear_key
  414  414   0001FB 180B 07xx           movb  #$07, masterstate         ; go to error decode state
             0001FF xx         
  415  415   000200 3D                  rts
  416  416                              
  417  417                      zero_error:
  418  418   000201 180B 01xx           movb  #$01, DMESS_EZ            ; set error flag for zero nint error  
             000205 xx         
  419  419   000206 16xx xx             jsr   clear_key
  420  420   000209 180B 07xx           movb  #$07, masterstate         ; go to error decode state
             00020D xx         
  421  421   00020E 3D                  rts
  422  422                              
  423  423                      null_error:        

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  424  424   00020F 180B 01xx           movb  #01,  DMESS_EN
             000213 xx         
  425  425   000214 16xx xx             jsr   clear_key
  426  426   000217 180B 07xx           movb  #$07, masterstate         ; go to error decode state
             00021B xx         
  427  427   00021C 3D                  rts
  428  428                       
  429  429                      
  430  430                      masterstate7: ;//  ERROR KEY  /////////////////////////////////////////////////////////////////
  431  431                              ; test if it should stay in error state and not allow additional key presses
  432  432                              ;load errocount1 into x
  433  433                              ;load errorcount2 into y
  434  434                              ;subtract them
  435  435                              ; if 0, they're equal (error decrementing finished) and we want to exit error state
  436  436                                    
  437  437   00021D FExx xx             ldx   ERRORCOUNT
  438  438   000220 8E0B B8             cpx   #$0BB8                   ; compare error count to max value, if not exit
  439  439   000223 260E                bne   errorstate_exit          ; if max, value has been reset, duration done
  440  440   000225 180B 01xx           movb  #$01, masterstate        ; exit error state on next pass
             000229 xx         
  441  441   00022A 79xx xx             clr   ERR_FLG
  442  442   00022D 16xx xx             jsr   clear_key
  443  443   000230 79xx xx             clr   KEY_COUNT
  444  444                              
  445  445                              
  446  446                      errorstate_exit:                            
  447  447   000233 3D                  rts
  448  448                      
  449  449                      ;//////////////////////////DISPLAY//////////////////////////////////////////////////// 
  450  450                      
  451  451                      display:
  452  452   000234 B6xx xx             ldaa   displaystate                 ; Display Task state cycling
  453  453   000237 1827 0038           lbeq   displaystateinit0
  454  454   00023B 43                  deca
  455  455   00023C 1827 0047           lbeq   displaystateinit1
  456  456   000240 43                  deca
  457  457   000241 1827 0061           lbeq   displaystatehub
  458  458   000245 43                  deca
  459  459   000246 1827 0157           lbeq   displaystateWAVE
  460  460   00024A 43                  deca
  461  461   00024B 1827 01B6           lbeq   displaystateNINT
  462  462   00024F 43                  deca
  463  463   000250 1827 01E9           lbeq   displaystateBS
  464  464   000254 43                  deca
  465  465   000255 1827 0206           lbeq   displaystateENT
  466  466   000259 43                  deca
  467  467   00025A 1827 021A           lbeq   displaystateEB
  468  468   00025E 43                  deca 
  469  469   00025F 1827 023F           lbeq   displaystateEZ
  470  470   000263 43                  deca
  471  471   000264 1827 0264           lbeq   displaystateEN
  472  472   000268 43                  deca
  473  473   000269 1827 00A8           lbeq   errordelay
  474  474   00026D 43                  deca
  475  475   00026E 1827 00EF           lbeq   displaystatekeyreset
  476  476                      
  477  477   000272 3D                  rts
  478  478                              
  479  479                      displaystateinit0:
  480  480   000273 16xx xx             jsr   INITLCD
  481  481   000276 180B 01xx           movb  #$01, FIRSTCH
             00027A xx         
  482  482   00027B 180B 01xx           movb  #$01, displaystate
             00027F xx         

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  483  483   000280 1803 0BB8           movw  #$0BB8, ERRORCOUNT
             000284 xxxx       
  484  484   000286 3D                  rts        
  485  485                      
  486  486                      
  487  487                      displaystateinit1:
  488  488   000287 16xx xx             jsr   startscreen                     ;after initialization
  489  489   00028A F7xx xx             tst   FIRSTCH
  490  490   00028D 2716                beq   displaystateinitexit
  491  491   00028F 180B 02xx           movb  #$02, displaystate
             000293 xx         
  492  492   000294 180B 00xx           movb  #$00, LASTCH
             000298 xx         
  493  493   000299 16xx xx             jsr   CURSOR_ON
  494  494   00029C 8600                ldaa  #$00
  495  495   00029E 7Axx xx             staa  CURSOR_ADD
  496  496   0002A1 16xx xx             jsr   SETADDR
  497  497                              
  498  498   0002A4 3D                  rts
  499  499                              
  500  500                      displaystateinitexit:
  501  501   0002A5 3D                  rts
  502  502                              
  503  503                      displaystatehub:
  504  504   0002A6 F7xx xx             tst   DWAVE
  505  505   0002A9 1826 0032           lbne   displaysetWAVE
  506  506   0002AD F7xx xx             tst   DPROMPT
  507  507   0002B0 1826 0031           lbne   displaysetNINT
  508  508   0002B4 F7xx xx             tst   DMESS_BS
  509  509   0002B7 1826 0030           lbne   displaysetBS
  510  510   0002BB F7xx xx             tst   DMESS_ENT
  511  511   0002BE 1826 002F           lbne   displaysetENT
  512  512   0002C2 F7xx xx             tst   DMESS_EB
  513  513   0002C5 1826 002E           lbne   displaysetEB
  514  514   0002C9 F7xx xx             tst   DMESS_EZ
  515  515   0002CC 1826 0031           lbne   displaysetEZ
  516  516   0002D0 F7xx xx             tst   DMESS_EN
  517  517   0002D3 1826 0034           lbne   displaysetEN
  518  518   0002D7 F7xx xx             tst   DMESS_RESET
  519  519   0002DA 1826 0051           lbne   displaystatereset
  520  520                                
  521  521   0002DE 3D                  rts
  522  522                              
  523  523                      displaysetWAVE:
  524  524   0002DF 180B 03xx           movb  #$03, displaystate
             0002E3 xx         
  525  525   0002E4 3D                  rts        
  526  526                      
  527  527                      displaysetNINT:
  528  528   0002E5 180B 04xx           movb  #$04, displaystate
             0002E9 xx         
  529  529   0002EA 3D                  rts
  530  530                      
  531  531                      displaysetBS:
  532  532   0002EB 180B 05xx           movb  #$05, displaystate
             0002EF xx         
  533  533   0002F0 3D                  rts   
  534  534                      
  535  535                      displaysetENT:
  536  536   0002F1 180B 06xx           movb  #$06, displaystate
             0002F5 xx         
  537  537   0002F6 3D                  rts
  538  538                      
  539  539                      displaysetEB:

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  540  540   0002F7 180B 07xx           movb  #$07, displaystate
             0002FB xx         
  541  541   0002FC 1873 xxxx           decw  ERRORCOUNT
  542  542   000300 3D                  rts   
  543  543                              
  544  544                      displaysetEZ:
  545  545   000301 180B 08xx           movb  #$08, displaystate
             000305 xx         
  546  546   000306 1873 xxxx           decw  ERRORCOUNT
  547  547   00030A 3D                  rts
  548  548                      
  549  549                      displaysetEN:
  550  550   00030B 180B 09xx           movb  #$09, displaystate
             00030F xx         
  551  551   000310 1873 xxxx           decw  ERRORCOUNT
  552  552   000314 3D                  rts
  553  553                              
  554  554                      errordelay:                                   ;error delay loop
  555  555   000315 18F7 xxxx           tstw  ERRORCOUNT                 ;
  556  556   000319 2708                beq   errorexit                       ;if error counter is 0, go to reset routine
  557  557   00031B 16xx xx             jsr   DELAY_1ms                       ;if error counts remain, delay 1ms
  558  558   00031E 1873 xxxx           decw  ERRORCOUNT                      ;if not, decrement error count
  559  559   000322 3D                  rts
  560  560                              
  561  561                      errorexit:                                    ;error reset routine
  562  562   000323 1803 0BB8           movw  #$0BB8, ERRORCOUNT              ;reload error count timer
             000327 xxxx       
  563  563   000329 180B 0Bxx           movb  #$0B, displaystate              ;change display state to screen reprint
             00032D xx         
  564  564   00032E 3D                  rts     
  565  565                              
  566  566                      displaystatereset:                            
  567  567   00032F F7xx xx             tst   FIRSTCH                    ;test if cursor is in correct position
  568  568   000332 1827 01C9           lbeq  PUTCHAR                    ;if so start/continue printing
  569  569   000336 F7xx xx             tst   LASTCH
  570  570   000339 2609                bne   displaystateresetexit
  571  571   00033B 8640                ldaa  #$40                       ;if not, new cursor address to first line, first pos
  572  572   00033D CExx xx             ldx   #CLR_MESS                  ;load x with blank lower line
  573  573   000340 16xx xx             jsr   PUTCHAR1ST                 ;set cursor to stated cursor address
  574  574   000343 3D                  rts
  575  575                              
  576  576                      displaystateresetexit:        
  577  577   000344 180B 00xx           movb  #$00,  LASTCH
             000348 xx         
  578  578   000349 180B 01xx           movb  #$01,  FIRSTCH
             00034D xx         
  579  579   00034E 180B 02xx           movb  #$02,  displaystate
             000352 xx         
  580  580   000353 180B 00xx           movb  #$00,  DMESS_RESET
             000357 xx         
  581  581   000358 8600                ldaa  #$00
  582  582   00035A 16xx xx             jsr   SETADDR
  583  583   00035D 16xx xx             jsr   CURSOR_ON
  584  584   000360 3D                  rts
  585  585                              
  586  586                      displaystatekeyreset:
  587  587   000361 F7xx xx             tst   FIRSTCH                    ;test if cursor is in correct position
  588  588   000364 1827 0197           lbeq  PUTCHAR                    ;if so start/continue printing
  589  589   000368 F7xx xx             tst   LASTCH
  590  590   00036B 2609                bne   displaystatekeyexit
  591  591   00036D 8655                ldaa  #$55                       ;if not, new cursor address to NINT cursor position
  592  592   00036F CExx xx             ldx   #KEYCLR_MESS               ;load x with black number input
  593  593   000372 16xx xx             jsr   PUTCHAR1ST                 ;set cursor to stated cursor address
  594  594   000375 3D                  rts

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  595  595                              
  596  596                      displaystatekeyexit:
  597  597   000376 180B 00xx           movb  #$00,  LASTCH
             00037A xx         
  598  598   00037B 180B 01xx           movb  #$01,  FIRSTCH
             00037F xx         
  599  599   000380 180B 02xx           movb  #$02,  displaystate
             000384 xx         
  600  600   000385 865B                ldaa  #$5B
  601  601   000387 7Axx xx             staa  CURSOR_ADD
  602  602   00038A 16xx xx             jsr   CURSOR_ON
  603  603   00038D 16xx xx             jsr   SETADDR
  604  604                              
  605  605   000390 3D                  rts
  606  606                              
  607  607                      
  608  608                      startscreen:
  609  609   000391 F7xx xx             tst   FIRSTCH                    ;test if cursor is in correct position
  610  610   000394 1827 0167           lbeq  PUTCHAR                    ;if so start/continue printing
  611  611   000398 8600                ldaa  #$00                       ;if not, new cursor address to first line, first pos
  612  612   00039A CExx xx             ldx   #SELECTION_SCREEN          ;load x with default screen message 1
  613  613   00039D 16xx xx             jsr   PUTCHAR1ST                 ;set cursor to stated cursor address
  614  614   0003A0 3D                  rts
  615  615                              
  616  616                      displaystateWAVE:
  617  617   0003A1 F7xx xx             tst   FIRSTCH                    ;test if this is first character in message
  618  618   0003A4 1827 0157           lbeq  PUTCHAR                    ;if so keep printing
  619  619   0003A8 F7xx xx             tst   LASTCH
  620  620   0003AB 2638                bne   waveexit  
  621  621   0003AD B6xx xx             ldaa  WAVE
  622  622   0003B0 8101                cmpa  #$01
  623  623   0003B2 270D                beq   sawdisp                    ;go to saw display if WAVE = 1
  624  624   0003B4 8102                cmpa  #$02
  625  625   0003B6 2712                beq   sine7disp                  ;go to sine7 display if WAVE = 2
  626  626   0003B8 8103                cmpa  #$03
  627  627   0003BA 2717                beq   squaredisp                 ;go to square display if WAVE = 3
  628  628   0003BC 8104                cmpa  #$04
  629  629   0003BE 271C                beq   sine15disp                 ;go to sine15 display if WAVE = 4
  630  630   0003C0 3D                  rts
  631  631                              
  632  632                      sawdisp:
  633  633   0003C1 8640                ldaa  #$40                       ;load starting message address
  634  634   0003C3 CExx xx             ldx   #SAW_MESS                  ;load 1st character of message memory location
  635  635   0003C6 16xx xx             jsr   PUTCHAR1ST                 ;initialize printing
  636  636   0003C9 3D                  rts
  637  637                      
  638  638                      sine7disp:
  639  639   0003CA 8640                ldaa  #$40
  640  640   0003CC CExx xx             ldx   #SINE7_MESS
  641  641   0003CF 16xx xx             jsr   PUTCHAR1ST
  642  642   0003D2 3D                  rts
  643  643                      
  644  644                      squaredisp:
  645  645   0003D3 8640                ldaa  #$40
  646  646   0003D5 CExx xx             ldx   #SQUARE_MESS
  647  647   0003D8 16xx xx             jsr   PUTCHAR1ST
  648  648   0003DB 3D                  rts
  649  649                      
  650  650                      sine15disp:  
  651  651   0003DC 8640                ldaa  #$40
  652  652   0003DE CExx xx             ldx   #SINE15_MESS
  653  653   0003E1 16xx xx             jsr   PUTCHAR1ST
  654  654   0003E4 3D                  rts
  655  655                              

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  656  656                      waveexit:
  657  657   0003E5 180B 00xx           movb  #$00, LASTCH
             0003E9 xx         
  658  658   0003EA 180B 00xx           movb  #$00, DWAVE
             0003EE xx         
  659  659   0003EF 180B 02xx           movb  #$02, displaystate
             0003F3 xx         
  660  660   0003F4 180B 01xx           movb  #$01, FIRSTCH
             0003F8 xx         
  661  661   0003F9 865B                ldaa  #$5B
  662  662   0003FB 7Axx xx             staa  CURSOR_ADD
  663  663   0003FE 16xx xx             jsr   SETADDR
  664  664   000401 16xx xx             jsr   CURSOR_ON
  665  665   000404 3D                  rts
  666  666                              
  667  667                              
  668  668                      displaystateNINT:
  669  669   000405 CDxx xx             ldy   #BUFFER                    ;get address of first buffer character
  670  670   000408 B6xx xx             ldaa  KEY_COUNT                  ;get keycount and decrement for proper offset
  671  671   00040B 43                  deca
  672  672   00040C EEEC                ldx   A, Y                       ;get offset address of key to print
  673  673   00040E B7C5                xgdx                             ;exchange values of d and x
  674  674   000410 1887                clrx                             ;clear x
  675  675   000412 7Axx xx             staa  ECHO                 
  676  676   000415 F6xx xx             ldab  ECHO                       
  677  677   000418 B6xx xx             ldaa  CURSOR_ADD
  678  678   00041B 16xx xx             jsr   OUTCHAR_AT                 ;print key at cursor address
  679  679   00041E B6xx xx             ldaa  CURSOR_ADD
  680  680   000421 42                  inca
  681  681   000422 7Axx xx             staa  CURSOR_ADD                 ;change cursor address to next digit location
  682  682   000425 16xx xx             jsr   SETADDR                    ;move cursor to stated location
  683  683   000428 180B 00xx           movb  #$00, LASTCH
             00042C xx         
  684  684   00042D 180B 01xx           movb  #$01, FIRSTCH                            
             000431 xx         
  685  685   000432 180B 00xx           movb  #$00, DPROMPT          ;reset flags, printing conditions
             000436 xx         
  686  686   000437 180B 02xx           movb  #$02, displaystate         ;go back to display hub
             00043B xx         
  687  687   00043C 3D                  rts
  688  688                      
  689  689                      displaystateBS:
  690  690   00043D B6xx xx             ldaa  CURSOR_ADD                 ;load a with current cursor address
  691  691   000440 43                  deca                             ;go back a space
  692  692   000441 7Axx xx             staa  CURSOR_ADD                 ;save that address
  693  693   000444 C620                ldab  #$20
  694  694   000446 16xx xx             jsr   OUTCHAR_AT                 ;print a space to previous digit location
  695  695   000449 B6xx xx             ldaa  CURSOR_ADD
  696  696   00044C 16xx xx             jsr   SETADDR                    ;move cursor to previous digit location
  697  697   00044F 180B 02xx           movb  #$02, displaystate         ;go back to display hub
             000453 xx         
  698  698   000454 180B 00xx           movb  #$00, LASTCH
             000458 xx         
  699  699   000459 180B 00xx           movb  #$00, DMESS_BS             ;reset flags, printing conditions
             00045D xx         
  700  700   00045E 3D                  rts
  701  701                              
  702  702                      displaystateENT:
  703  703   00045F 16xx xx             jsr   CURSOR_OFF
  704  704   000462 180B 00xx           movb  #$00, CURSOR_ADD           ;hide cursor
             000466 xx         
  705  705   000467 B6xx xx             ldaa  CURSOR_ADD
  706  706   00046A 16xx xx             jsr   SETADDR                    ;move cursor to hide address
  707  707   00046D 180B 02xx           movb  #$02, displaystate         ;go back to display hub

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
             000471 xx         
  708  708   000472 180B 00xx           movb  #$00, DMESS_ENT            ;clear enter message flag
             000476 xx         
  709  709   000477 3D                  rts
  710  710                              
  711  711                      
  712  712                      displaystateEB:
  713  713   000478 F7xx xx             tst   FIRSTCH
  714  714   00047B 1827 0080           lbeq  PUTCHAR
  715  715   00047F F7xx xx             tst   LASTCH
  716  716   000482 2609                bne   EBexit
  717  717   000484 8655                ldaa  #$55
  718  718   000486 CExx xx             ldx   #EB_MESS
  719  719   000489 16xx xx             jsr   PUTCHAR1ST
  720  720   00048C 3D                  rts
  721  721                              
  722  722                      EBexit:
  723  723   00048D 180B 00xx           movb  #$00, LASTCH
             000491 xx         
  724  724   000492 180B 0Axx           movb  #$0A, displaystate
             000496 xx         
  725  725   000497 180B 00xx           movb  #$00, DMESS_EB
             00049B xx         
  726  726   00049C 180B 01xx           movb  #$01, FIRSTCH
             0004A0 xx         
  727  727   0004A1 3D                  rts
  728  728                              
  729  729                      displaystateEZ:
  730  730   0004A2 F7xx xx             tst   FIRSTCH
  731  731   0004A5 1827 0056           lbeq  PUTCHAR
  732  732   0004A9 F7xx xx             tst   LASTCH
  733  733   0004AC 2609                bne   EZexit
  734  734   0004AE 8655                ldaa  #$55
  735  735   0004B0 CExx xx             ldx   #EZ_MESS
  736  736   0004B3 16xx xx             jsr   PUTCHAR1ST
  737  737   0004B6 3D                  rts
  738  738                              
  739  739                      EZexit:
  740  740   0004B7 180B 00xx           movb  #$00, LASTCH
             0004BB xx         
  741  741   0004BC 180B 0Axx           movb  #$0A, displaystate
             0004C0 xx         
  742  742   0004C1 180B 00xx           movb  #$00, DMESS_EZ
             0004C5 xx         
  743  743   0004C6 180B 01xx           movb  #$01, FIRSTCH
             0004CA xx         
  744  744   0004CB 3D                  rts
  745  745                              
  746  746                      displaystateEN:
  747  747   0004CC F7xx xx             tst   FIRSTCH
  748  748   0004CF 1827 002C           lbeq  PUTCHAR
  749  749   0004D3 F7xx xx             tst   LASTCH
  750  750   0004D6 2609                bne   ENexit
  751  751   0004D8 8655                ldaa  #$55
  752  752   0004DA CExx xx             ldx   #EN_MESS
  753  753   0004DD 16xx xx             jsr   PUTCHAR1ST
  754  754   0004E0 3D                  rts
  755  755                              
  756  756                      ENexit:
  757  757   0004E1 180B 00xx           movb  #$00, LASTCH
             0004E5 xx         
  758  758   0004E6 180B 0Axx           movb  #$0A, displaystate
             0004EA xx         
  759  759   0004EB 180B 00xx           movb  #$00, DMESS_EN

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
             0004EF xx         
  760  760   0004F0 180B 01xx           movb  #$01, FIRSTCH
             0004F4 xx         
  761  761   0004F5 3D                  rts
  762  762                              
  763  763                      PUTCHAR1ST:
  764  764   0004F6 7Exx xx             stx   DPTR
  765  765   0004F9 16xx xx             jsr   SETADDR
  766  766   0004FC 79xx xx             clr   FIRSTCH
  767  767                              
  768  768                      PUTCHAR:           
  769  769   0004FF FExx xx             ldx   DPTR
  770  770   000502 E600                ldab  0,X
  771  771   000504 2708                beq   DONE
  772  772   000506 08                  inx
  773  773   000507 7Exx xx             stx   DPTR
  774  774   00050A 16xx xx             jsr   OUTCHAR
  775  775   00050D 3D                  rts
  776  776                      DONE:
  777  777   00050E 180B 01xx           movb  #$01, FIRSTCH
             000512 xx         
  778  778   000513 180B 01xx           movb  #$01, LASTCH
             000517 xx         
  779  779   000518 3D                  rts
  780  780                      ;//////////////////////////KEYPAD/////////////////////////////////////////////////////
  781  781                      
  782  782                      keypad:
  783  783                              
  784  784                      keyloop:
  785  785   000519 B6xx xx             ldaa  keystate                 ; get current t1state and branch accordingly 
  786  786   00051C 2708                beq   keystate0 
  787  787   00051E 43                  deca 
  788  788   00051F 270E                beq   keystate1 
  789  789   000521 43                  deca 
  790  790   000522 2721                beq   keystate2 
  791  791                              
  792  792   000524 20F3                bra   keyloop
  793  793                              
  794  794                      
  795  795                      keystate0:                             ;init keypad state
  796  796   000526 16xx xx             jsr   INITKEY
  797  797   000529 180B 01xx           movb  #$01, keystate           ;go to keystate 1 on next passthrough
             00052D xx         
  798  798   00052E 3D                  rts
  799  799                      
  800  800                      keystate1:
  801  801   00052F F7xx xx             tst   LKEY_FLG                 ;see if key was pressed
  802  802   000532 2710                beq   exitkeystate1            ;if no key pressed, rts
  803  803   000534 180B 01xx           movb  #$01,   KEY_FLG          ;set keyflag if key pressed
             000538 xx         
  804  804   000539 16xx xx             jsr   GETCHAR                  ;get character
  805  805   00053C 7Bxx xx             stab  KEY_BUFFER               ;store character in key buffer
  806  806   00053F 180B 02xx           movb  #$02, keystate           ;go to state 2 on next passthrough
             000543 xx         
  807  807                              
  808  808                      exitkeystate1:
  809  809   000544 3D                  rts
  810  810                              
  811  811                      keystate2:
  812  812   000545 F7xx xx             tst   KEY_FLG                 
  813  813   000548 2605                bne   exitkeystate2            ;if key flag cleared by mastermind
  814  814   00054A 180B 01xx           movb  #$01, keystate           ;go back to state 1
             00054E xx         
  815  815                      

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  816  816                      exitkeystate2:
  817  817   00054F 3D                  rts
  818  818                      
  819  819                      ;//////////////////////////FUNCTION_GENERATOR/////////////////////////////////////////
  820  820                      
  821  821                      function_generator:
  822  822                      
  823  823   000550 B6xx xx             ldaa  fxngenstate
  824  824   000553 1827 0014           lbeq   fxngenstate0
  825  825   000557 43                  deca
  826  826   000558 1827 0014           lbeq   fxngenstate1
  827  827   00055C 43                  deca
  828  828   00055D 1827 0050           lbeq   fxngenstate2
  829  829   000561 43                  deca
  830  830   000562 1827 0076           lbeq   fxngenstate3
  831  831   000566 43                  deca
  832  832   000567 1827 008F           lbeq   fxngenstate4
  833  833                              
  834  834                      fxngenstate0:
  835  835   00056B 180B 01xx           movb  #$01, fxngenstate     ; initialize
             00056F xx         
  836  836                      
  837  837                      fxngenstate1:
  838  838   000570 F7xx xx             tst   WAVE                  ; test if new wave has been selected
  839  839   000573 273B                beq   fxns1exit             ; if not, exit
  840  840   000575 B6xx xx             ldaa  WAVE                  ; test respective waves for loading proper addresses
  841  841   000578 8101                cmpa  #$01
  842  842   00057A 270E                beq   sawfxnset
  843  843   00057C 8102                cmpa  #$02
  844  844   00057E 2712                beq   sine7fxnset
  845  845   000580 8103                cmpa  #$03
  846  846   000582 2716                beq   squarefxnset
  847  847   000584 8104                cmpa  #$04
  848  848   000586 271A                beq   sine15fxnset
  849  849   000588 2026                bra   fxns1exit
  850  850                              
  851  851                      sawfxnset:
  852  852   00058A CExx xx             ldx   #SAW_WAVE              ; load respective wave beginning address
  853  853   00058D 7Exx xx             stx   WAVEPTR                ; into wave pointer
  854  854   000590 2018                bra   fxnsetexit
  855  855                              
  856  856                      sine7fxnset:
  857  857   000592 CExx xx             ldx   #SINE7_WAVE
  858  858   000595 7Exx xx             stx   WAVEPTR
  859  859   000598 2010                bra   fxnsetexit
  860  860                              
  861  861                      squarefxnset:
  862  862   00059A CExx xx             ldx   #SQUARE_WAVE
  863  863   00059D 7Exx xx             stx   WAVEPTR
  864  864   0005A0 2008                bra   fxnsetexit
  865  865                              
  866  866                      sine15fxnset:
  867  867   0005A2 CExx xx             ldx   #SINE15_WAVE
  868  868   0005A5 7Exx xx             stx   WAVEPTR
  869  869   0005A8 2000                bra   fxnsetexit
  870  870                              
  871  871                      fxnsetexit:         
  872  872   0005AA 180B 02xx           movb  #$02, fxngenstate     ; if so, move to wave loading next pass
             0005AE xx         
  873  873   0005AF 3D                  rts
  874  874                              
  875  875                      fxns1exit: 
  876  876   0005B0 3D                  rts        
  877  877                      

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  878  878                      
  879  879                      fxngenstate2:                       ; NEW WAVE
  880  880                              
  881  881   0005B1 F7xx xx             tst    DWAVE                ; wait for display of wave message 
  882  882   0005B4 2625                bne    fxngens2exit 
  883  883   0005B6 FExx xx             ldx    WAVEPTR              ; point to start of data for wave 
  884  884   0005B9 180D 00xx           movb   0,X, CSEG            ; get number of wave segments 
             0005BD xx         
  885  885   0005BE 1805 01xx           movw   1,X, VALUE           ; get initial value for DAC 
             0005C2 xx         
  886  886   0005C3 180D 03xx           movb   3,X, LSEG            ; load segment length 
             0005C7 xx         
  887  887   0005C8 1805 04xx           movw   4,X, SEGINC          ; load segment increment 
             0005CC xx         
  888  888   0005CD 08                  inx                         ; inc SEGPTR to next segment 
  889  889   0005CE 08                  inx 
  890  890   0005CF 08                  inx 
  891  891   0005D0 08                  inx 
  892  892   0005D1 08                  inx 
  893  893   0005D2 08                  inx 
  894  894   0005D3 7Exx xx             stx    SEGPTR               ; store incremented SEGPTR for next segment  
  895  895   0005D6 180B 03xx           movb   #$03, fxngenstate    ; set next state 
             0005DA xx         
  896  896                      fxngens2exit:
  897  897   0005DB 3D                  rts 
  898  898                       
  899  899                      fxngenstate3:
  900  900   0005DC F7xx xx             tst   NINT_OK               ;test if NINT value successfully entered
  901  901   0005DF 2718                beq   fxngens3exit
  902  902   0005E1 180B 01xx           movb  #$01, RUN_FLG
             0005E5 xx         
  903  903   0005E6 180B 00xx           movb  #$00, NINT_OK
             0005EA xx         
  904  904   0005EB 180B 04xx           movb  #$04, fxngenstate
             0005EF xx         
  905  905   0005F0 B6xx xx             ldaa  LSEG
  906  906   0005F3 8B01                adda  #$01
  907  907   0005F5 7Axx xx             staa  LSEG
  908  908   0005F8 3D                  rts
  909  909                              
  910  910                      fxngens3exit:
  911  911   0005F9 3D                  rts
  912  912                      
  913  913                      fxngenstate4:                   ; DISPLAY WAVE
  914  914   0005FA F7xx xx             tst    RUN_FLG 
  915  915   0005FD 273B                beq    fxngens4c        ; do not update function generator if RUN=0 
  916  916   0005FF F7xx xx             tst    NEW_BTI 
  917  917   000602 273E                beq    fxngens4e        ; do not update function generator if NEWBTI=0 
  918  918   000604 73xx xx             dec    LSEG             ; decrement segment length counter 
  919  919   000607 2626                bne    fxngens4b        ; if not at end, simply update DAC output 
  920  920   000609 73xx xx             dec    CSEG             ; if at end, decrement segment counter 
  921  921   00060C 260E                bne    fxngens4a        ; if not last segment, skip reinit of wave 
  922  922   00060E FExx xx             ldx    WAVEPTR          ; point to start of data for wave 
  923  923   000611 180D 00xx           movb   0,X, CSEG        ; get number of wave segments 
             000615 xx         
  924  924   000616 08                  inx                     ; inc SEGPTR to start of first segment 
  925  925   000617 08                  inx 
  926  926   000618 08                  inx 
  927  927   000619 7Exx xx             stx    SEGPTR           ; store incremented SEGPTR 
  928  928                      fxngens4a:  
  929  929   00061C FExx xx             ldx    SEGPTR           ; point to start of new segment 
  930  930   00061F 180D 00xx           movb   0,X, LSEG        ; initialize segment length counter 
             000623 xx         
  931  931   000624 1805 01xx           movw   1,X, SEGINC      ; load segment increment 

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
             000628 xx         
  932  932   000629 08                  inx                     ; inc SEGPTR to next segment 
  933  933   00062A 08                  inx 
  934  934   00062B 08                  inx 
  935  935   00062C 7Exx xx             stx    SEGPTR           ; store incremented SEGPTR 
  936  936                      fxngens4b:  
  937  937   00062F FCxx xx             ldd    VALUE            ; get current DAC input value 
  938  938   000632 F3xx xx             addd   SEGINC           ; add SEGINC to current DAC input value 
  939  939   000635 7Cxx xx             std    VALUE            ; store incremented DAC input value 
  940  940   000638 2005                bra    fxngens4d 
  941  941                      fxngens4c:  
  942  942   00063A 180B 01xx           movb   #$01, fxngenstate    ; set next state 
             00063E xx         
  943  943                      fxngens4d:  
  944  944   00063F 79xx xx             clr    NEW_BTI 
  945  945                      fxngens4e:  
  946  946   000642 3D                  rts 
  947  947                              
  948  948                      ISR:                                   
  949  949                              
  950  950   000643 73xx xx             dec   CINT
  951  951   000646 2611                bne   NOT_YET
  952  952   000648 FCxx xx             ldd   VALUE
  953  953   00064B 16xx xx             jsr   OUTDACA
  954  954   00064E 180C xxxx           movb  NINT, CINT
             000652 xxxx       
  955  955   000654 180B 01xx           movb  #$01, NEW_BTI
             000658 xx         
  956  956                              
  957  957                      NOT_YET:
  958  958   000659 DC50                ldd   TC0                     ; load $0044:$0045 into d
  959  959   00065B C303 E0             addd  #INTERVAL                ; add interval to timer count
  960  960   00065E 5C50                std   TC0                      ; store in timer channel 0
  961  961   000660 4C4E 01             bset  TFLG1, C0F               ; clear timer output compare flag by writing a 1 to it
  962  962   000663 0B                  rti
  963  963                          
  964  964                              
  965  965                      
  966  966                      
  967  967                      ;/------------------------------------------------------------------------------------\
  968  968                      ;| Subroutines                                                                        |
  969  969                      ;\------------------------------------------------------------------------------------/
  970  970                      ; General purpose subroutines go here
  971  971                      ;// BUFFER STORE //        
  972  972                      buffer_store:   
  973  973   000664 B6xx xx             ldaa  KEY_COUNT
  974  974   000667 8103                cmpa  #$03                     ; make sure there aren't more than 3 keys in buffer (would overflow)
  975  975   000669 2411                bhs   clear_key
  976  976   00066B 180B 01xx           movb  #$01, DMESS_NINT
             00066F xx         
  977  977   000670 CExx xx             ldx   #BUFFER
  978  978                              
  979  979   000673 F6xx xx             ldab  KEY_BUFFER               ; store digit
  980  980   000676 6BE4                stab  a, x               ; a should still be key_count
  981  981   000678 72xx xx             inc   KEY_COUNT                ; +1 keys in buffer now
  982  982   00067B 3D                  rts                            ; exit, key clearing done in state3 before exit
  983  983                      
  984  984                       ;// CLEAR KEY ////       
  985  985                      clear_key:
  986  986   00067C 79xx xx             clr   KEY_BUFFER
  987  987   00067F 79xx xx             clr   KEY_FLG
  988  988   000682 180B 01xx           movb  #$01, masterstate         ; go back to waiting for key press
             000686 xx         
  989  989   000687 3D                  rts

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
  990  990                      
  991  991                      ;//  ASCII DECODE //////
  992  992                      asc_decode:
  993  993                              ; NOTE: most of these variables could be circumvented by using storage that's already defined
  994  994                              ; this could be implemented later, but the fast solution was used first.
  995  995                              ; OUTPUTS: x result, a is error code
  996  996                              ; ERROR CODES: 0 if no error, 1 if overflow error, 2 if zero error
  997  997   000688 79xx xx             clr   COUNT                          ; prep intermediate variables
  998  998   00068B 79xx xx             clr   TEMP
  999  999   00068E 1879 xxxx           clrw  RESULT
 1000 1000                              
 1001 1001   000692 180C xxxx           movb  KEY_COUNT, COUNT              ; move byte to decrementer
             000696 xxxx       
 1002 1002                              
 1003 1003                              ; store the registers and accumulators
 1004 1004   000698 39                  pshc                                 ; push ccr to stack
 1005 1005   000699 37                  pshb                                 ; push b to stack
 1006 1006   00069A 35                  pshy                                 ; push y to stack
 1007 1007                              
 1008 1008   00069B CExx xx             ldx   #BUFFER                        ; load x for indexed addressing
 1009 1009                      
 1010 1010                              
 1011 1011                      while:                                       ; loop through each digit
 1012 1012                              
 1013 1013   00069E B6xx xx             ldaa  TEMP                           ; counter for number of digits to index
 1014 1014                             
 1015 1015   0006A1 E6E4                ldab  a,x                            ; retrieve desired value from buffer
 1016 1016   0006A3 C030                subb  #$30                           ; get BCD by subtracting 30
 1017 1017   0006A5 72xx xx             inc   TEMP                           ; increment TEMP
 1018 1018                              
 1019 1019   0006A8 FDxx xx             ldy   RESULT                         ; load y with current result
 1020 1020   0006AB 19ED                aby                                  ; add latest digit
 1021 1021   0006AD 7Dxx xx             sty   RESULT                         ; then store back in result
 1022 1022   0006B0 FCxx xx             ldd   RESULT
 1023 1023   0006B3 97                  tsta
 1024 1024   0006B4 2623                bne   overflowerror                  ; check that adding didn't create overflow
 1025 1025                              
 1026 1026   0006B6 73xx xx             dec   COUNT                          ; decrement count
 1027 1027   0006B9 F6xx xx             ldab  COUNT                          ; load into b to check if done
 1028 1028   0006BC C100                cmpb  #$00                           ; if count is zero, the subroutine is done
 1029 1029   0006BE 270D                beq   return                         ; if that was last digit, don't mult by 10
 1030 1030                              
 1031 1031   0006C0 CC00 0A             ldd   #$000A                         ; for mult by 10, y already loaded
 1032 1032   0006C3 13                  emul                                 ; y x d, store in y:d
 1033 1033   0006C4 8100                cmpa  #$00                           ; y should be empty or we have overflow
 1034 1034   0006C6 2611                bne   overflowerror                  ; error routine if error occurred
 1035 1035   0006C8 7Cxx xx             std   RESULT                         ; store the result in result
 1036 1036   0006CB 20D1                bra   while                          ; keep looping while count > 0
 1037 1037                              
 1038 1038                      return:
 1039 1039   0006CD FExx xx             ldx   RESULT                         ; load x
 1040 1040   0006D0 8E00 00             cpx   #$0000                           ; check for zero result
 1041 1041   0006D3 2708                beq   zeroerror                      ; if result was empty, zero error
 1042 1042   0006D5 8600                ldaa  #$00                           ; if it got here, it didn't hit an error                         ; return result in x r
 1043 1043   0006D7 2008                bra   restore                        ; exit routine
 1044 1044                      
 1045 1045                      overflowerror:
 1046 1046   0006D9 8601                ldaa  #$01                           ; error code for overflow error
 1047 1047   0006DB 2004                bra   restore                        ; exit routine
 1048 1048                      
 1049 1049                      zeroerror:
 1050 1050   0006DD 8602                ldaa  #$02                           ; error code for zero error
 1051 1051   0006DF 2000                bra   restore                        ; exit routine
 1052 1052                              

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1053 1053                      restore:                                     ; LIFO, restores accumulators, registers, CCR, 
 1054 1054   0006E1 31                  puly                                 ; restore index register y from stack
 1055 1055   0006E2 33                  pulb                                 ; restore accumulator b from stack
 1056 1056   0006E3 38                  pulc                                 ; restore ccr from stack
 1057 1057   0006E4 3D                  rts                                  ; ouput is 
 1058 1058                              
 1059 1059                      DELAY_1ms: 
 1060 1060   0006E5 CD05 84             ldy   #$0584 
 1061 1061                      INNER:                                 ; inside loop 
 1062 1062   0006E8 8D00 00             cpy   #0 
 1063 1063   0006EB 2703                beq   EXIT 
 1064 1064   0006ED 03                  dey 
 1065 1065   0006EE 20F8                bra   INNER 
 1066 1066                      EXIT: 
 1067 1067   0006F0 3D                  rts                            ; exit DELAY_1ms 
 1068 1068                      
 1069 1069                      
 1070 1070                      ;/------------------------------------------------------------------------------------\
 1071 1071                      ;| ASCII Messages and Constant Data                                                   |
 1072 1072                      ;\------------------------------------------------------------------------------------/
 1073 1073                      ; Any constants can be defined here
 1074 1074                      
 1075 1075   0006F1 313A 2053   SELECTION_SCREEN:       DC.B    '1: SAW, 2: SINE-7, 3: SQUARE, 4: SINE-15', $00
             0006F5 4157 2C20  
             0006F9 323A 2053  
             0006FD 494E 452D  
             000701 372C 2033  
             000705 3A20 5351  
             000709 5541 5245  
             00070D 2C20 343A  
             000711 2053 494E  
             000715 452D 3135  
             000719 00         
 1076 1076   00071A 5341 5754   SAW_MESS:               DC.B    'SAWTOOTH WAVE        NINT:     [1-->255]', $00
             00071E 4F4F 5448  
             000722 2057 4156  
             000726 4520 2020  
             00072A 2020 2020  
             00072E 204E 494E  
             000732 543A 2020  
             000736 2020 205B  
             00073A 312D 2D3E  
             00073E 3235 355D  
             000742 00         
 1077 1077   000743 372D 5345   SINE7_MESS:             DC.B    '7-SEGMENT SINE WAVE  NINT:     [1-->255]', $00
             000747 474D 454E  
             00074B 5420 5349  
             00074F 4E45 2057  
             000753 4156 4520  
             000757 204E 494E  
             00075B 543A 2020  
             00075F 2020 205B  
             000763 312D 2D3E  
             000767 3235 355D  
             00076B 00         
 1078 1078   00076C 5351 5541   SQUARE_MESS:            DC.B    'SQUARE WAVE          NINT:     [1-->255]', $00
             000770 5245 2057  
             000774 4156 4520  
             000778 2020 2020  
             00077C 2020 2020  
             000780 204E 494E  
             000784 543A 2020  
             000788 2020 205B  
             00078C 312D 2D3E  

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
             000790 3235 355D  
             000794 00         
 1079 1079   000795 3135 2D53   SINE15_MESS:            DC.B    '15-SEGMENT SINE WAVE NINT:     [1-->255]', $00
             000799 4547 4D45  
             00079D 4E54 2053  
             0007A1 494E 4520  
             0007A5 5741 5645  
             0007A9 204E 494E  
             0007AD 543A 2020  
             0007B1 2020 205B  
             0007B5 312D 2D3E  
             0007B9 3235 355D  
             0007BD 00         
 1080 1080   0007BE 4E49 4E54   KEYCLR_MESS:            DC.B    'NINT:     [1-->255]', $00
             0007C2 3A20 2020  
             0007C6 2020 5B31  
             0007CA 2D2D 3E32  
             0007CE 3535 5D00  
 1081 1081   0007D2 2020 2020   CLR_MESS:               DC.B    '                                        ', $00
             0007D6 2020 2020  
             0007DA 2020 2020  
             0007DE 2020 2020  
             0007E2 2020 2020  
             0007E6 2020 2020  
             0007EA 2020 2020  
             0007EE 2020 2020  
             0007F2 2020 2020  
             0007F6 2020 2020  
             0007FA 00         
 1082 1082   0007FB 4D41 474E   EB_MESS:                DC.B    'MAGNITUDE TOO LARGE', $00
             0007FF 4954 5544  
             000803 4520 544F  
             000807 4F20 4C41  
             00080B 5247 4500  
 1083 1083   00080F 5A45 524F   EZ_MESS:                DC.B    'ZERO MAGNITUDE     ', $00
             000813 204D 4147  
             000817 4E49 5455  
             00081B 4445 2020  
             00081F 2020 2000  
 1084 1084   000823 4E4F 2044   EN_MESS:                DC.B    'NO DIGITS ENTERED  ', $00
             000827 4947 4954  
             00082B 5320 454E  
             00082F 5445 5245  
             000833 4420 2000  
 1085 1085                      
 1086 1086                      SAW_WAVE:
 1087 1087   000837 02                                  DC.B  2                 ; number of segments for SAWTOOTH 
 1088 1088   000838 0000                                DC.W  0                 ; initial DAC input value
 1089 1089   00083A 13                                  DC.B  19                ; length for segment_1
 1090 1090   00083B 00AC                                DC.W  172               ; increment for segment_1
 1091 1091   00083D 01                                  DC.B  1                 ; length for segment_2
 1092 1092   00083E F33C                                DC.W  -3268             ; increment for segment_2
 1093 1093                                              
 1094 1094                      SINE7_WAVE:
 1095 1095   000840 07                                  DC.B  7                 ; number of segments for SINE-7 
 1096 1096   000841 0800                                DC.W  2048              ; initial DAC input value 
 1097 1097   000843 19                                  DC.B  25                ; length for segment_1 
 1098 1098   000844 0020                                DC.W  32                ; increment for segment_1 
 1099 1099   000846 32                                  DC.B  50                ; length for segment_2 
 1100 1100   000847 0010                                DC.W  16                ; increment for segment_2 
 1101 1101   000849 32                                  DC.B  50                ; length for segment_3 
 1102 1102   00084A FFF0                                DC.W  -16               ; increment for segment_3 
 1103 1103   00084C 32                                  DC.B  50                ; length for segment_4 
 1104 1104   00084D FFE0                                DC.W  -32               ; increment for segment_4 

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1105 1105   00084F 32                                  DC.B  50                ; length for segment_5 
 1106 1106   000850 FFF0                                DC.W  -16               ; increment for segment_5 
 1107 1107   000852 32                                  DC.B  50                ; length for segment_6 
 1108 1108   000853 0010                                DC.W  16                ; increment for segment_6 
 1109 1109   000855 19                                  DC.B  25                ; length for segment_7 
 1110 1110   000856 0020                                DC.W  32                ; increment for segment_7
 1111 1111                      SQUARE_WAVE:
 1112 1112   000858 04                                  DC.B  4                 ; number of segments for SQUARE 
 1113 1113   000859 0CCC                                DC.W  3276              ; initial DAC input value
 1114 1114   00085B 09                                  DC.B  9                 ; length for segment_1
 1115 1115   00085C 0000                                DC.W  0                 ; increment for segment_1
 1116 1116   00085E 01                                  DC.B  1                 ; length for segment_2
 1117 1117   00085F F334                                DC.W  -3276             ; increment for segment_2
 1118 1118   000861 09                                  DC.B  9                 ; length for segment_3
 1119 1119   000862 0000                                DC.W  0                 ; increment for segment_3
 1120 1120   000864 01                                  DC.B  1                 ; length for segment_4
 1121 1121   000865 0CCC                                DC.W  3276              ; increment for segment_4
 1122 1122                                              
 1123 1123                      SINE15_WAVE:
 1124 1124   000867 0F                                  DC.B  15                ; number of segments for SINE-15 
 1125 1125   000868 0800                                DC.W  2048              ; initial DAC input value 
 1126 1126   00086A 0A                                  DC.B  10                ; length for segment_1 
 1127 1127   00086B 0029                                DC.W  41                ; increment for segment_1 
 1128 1128   00086D 15                                  DC.B  21                ; length for segment_2 
 1129 1129   00086E 0025                                DC.W  37                ; increment for segment_2 
 1130 1130   000870 15                                  DC.B  21                ; length for segment_3 
 1131 1131   000871 0019                                DC.W  25                ; increment for segment_3 
 1132 1132   000873 15                                  DC.B  21                ; length for segment_4 
 1133 1133   000874 0009                                DC.W  9                 ; increment for segment_4 
 1134 1134   000876 15                                  DC.B  21                ; length for segment_5 
 1135 1135   000877 FFF7                                DC.W  -9                ; increment for segment_5 
 1136 1136   000879 15                                  DC.B  21                ; length for segment_6 
 1137 1137   00087A FFE7                                DC.W  -25               ; increment for segment_6 
 1138 1138   00087C 15                                  DC.B  21                ; length for segment_7 
 1139 1139   00087D FFDB                                DC.W  -37               ; increment for segment_7 
 1140 1140   00087F 14                                  DC.B  20                ; length for segment_8 
 1141 1141   000880 FFD7                                DC.W  -41               ; increment for segment_8 
 1142 1142   000882 15                                  DC.B  21                ; length for segment_9 
 1143 1143   000883 FFDB                                DC.W  -37               ; increment for segment_9 
 1144 1144   000885 15                                  DC.B  21                ; length for segment_10 
 1145 1145   000886 FFE7                                DC.W  -25               ; increment for segment_10 
 1146 1146   000888 15                                  DC.B  21                ; length for segment_11 
 1147 1147   000889 FFF7                                DC.W  -9                ; increment for segment_11 
 1148 1148   00088B 15                                  DC.B  21                ; length for segment_12 
 1149 1149   00088C 0009                                DC.W  9                 ; increment for segment_12 
 1150 1150   00088E 15                                  DC.B  21                ; length for segment_13 
 1151 1151   00088F 0019                                DC.W  25                ; increment for segment_13 
 1152 1152   000891 15                                  DC.B  21                ; length for segment_14 
 1153 1153   000892 0025                                DC.W  37                ; increment for segment_14 
 1154 1154   000894 0A                                  DC.B  10                ; length for segment_15 
 1155 1155   000895 0029                                DC.W  41                ; increment for segment_15 
 1156 1156                      
 1157 1157                      
 1158 1158                      
 1159 1159                      
 1160 1160                      ;/------------------------------------------------------------------------------------\
 1161 1161                      ;| Vectors                                                                            |
 1162 1162                      ;\------------------------------------------------------------------------------------/
 1163 1163                      ; Add interrupt and reset vectors here
 1164 1164                              ORG   $FFEE                    ; timer ch0 vector address
 1165 1165  a00FFEE xxxx                DC.W  ISR
 1166 1166                              ORG   $FFFE                    ; reset vector address
 1167 1167  a00FFFE xxxx                DC.W  Entry
 1168 1168                              ORG   $FFCE                    ; Key Wakeup interrupt vector address [Port J]

Freescale HC12-Assembler 
(c) Copyright Freescale 1987-2010

 Abs. Rel.   Loc    Obj. code   Source line
 ---- ----   ------ ---------   -----------
 1169 1169  a00FFCE xxxx                DC.W  ISR_KEYPAD
